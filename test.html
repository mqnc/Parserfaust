<html>

<head>
	<meta charset="utf-8" />
	<style>
		:root {
			--editor-fg: black;
			--editor-bg: #cad8db;
			--editor-border: #333333;
			--update-fg: black;
			--update-bg: gold;
			--enter-fg: white;
			--enter-bg: #5599ff;
			--accept-fg: black;
			--accept-bg: #45e600;
			--reject-fg: black;
			--reject-bg: #ff570f;
			--not-in-stack-fg: #444444;
			--in-stack-bg: rgba(85, 153, 255, 0.14);
		}

		body {
			font-family: monospace;
			margin: 0px;
		}

		div {
			color: var(--editor-fg);
			background-color: var(--editor-bg);
			border: solid 1px var(--editor-border);
			position: absolute;
		}

		button {
			line-height: 1em;
		}

		.header {
			left: 5px;
			top: 5px;
			width: calc(100% - 10px);
			height: 2em;
		}

		.grammar {
			left: 5px;
			top: calc(10px + 2em);
			width: calc(0.45*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.stack {
			left: calc(10px + 0.45*(100% - 20px));
			top: calc(10px + 2em);
			width: calc(0.1*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.source {
			left: calc(15px + 0.55*(100% - 20px));
			top: calc(10px + 2em);
			width: calc(0.45*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.footer {
			left: 5px;
			top: calc(100% - 5px - 2em);
			width: calc(100% - 10px);
			height: 2em;
		}

		p {
			color: var(--not-in-stack-fg);
			margin-top: 0.2em;
			margin-bottom: 0.6em;
			padding-left: 3em;
			text-indent: -3em;
		}

		td {
			vertical-align: top;
		}

		span.inStack {
			background-color: var(--in-stack-bg);
		}

		.enter {
			color: var(--enter-fg);
			background-color: var(--enter-bg);
		}

		.enter0 {
			background: linear-gradient(90deg, var(--enter-bg) 0%, var(--editor-bg) 70%);
		}

		.accept {
			color: var(--accept-fg);
			background-color: var(--accept-bg);
		}

		.accept0 {
			background: linear-gradient(90deg, var(--accept-bg) 0%, var(--editor-bg) 70%);
		}

		.reject {
			color: var(--reject-fg);
			background-color: var(--reject-bg);
		}

		.reject0 {
			background: linear-gradient(90deg, var(--reject-bg) 0%, var(--editor-bg) 70%);
		}

		.update {
			color: var(--update-fg);
			background-color: var(--update-bg);
		}
	</style>
	<script src="test.js"></script>
	<script>

		let source = `# Hierarchical syntax
Grammar    <- Spacing Definition+ EndOfFile
Definition <- Identifier LEFTARROW Expression

Expression <- Sequence (SLASH Sequence)*
Sequence   <- Prefix*
Prefix     <- (AND / NOT)? Suffix
Suffix     <- Primary (QUESTION / STAR / PLUS)?
Primary    <- Identifier !LEFTARROW
            / OPEN Expression CLOSE
            / Literal / Class / DOT

# Lexical syntax
Identifier <- IdentStart IdentCont* Spacing
IdentStart <- [a-zA-Z_]
IdentCont  <- IdentStart / [0-9]

Literal    <- ['] (!['] Char)* ['] Spacing
            / ["] (!["] Char)* ["] Spacing
Class      <- '[' (!']' Range)* ']' Spacing
Range      <- Char '-' Char / Char
Char       <- '\\\\' [nrt'"\\[\\]\\\\]
            / '\\\\' [0-2][0-7][0-7]
            / '\\\\' [0-7][0-7]?
            / !'\\\\' .

LEFTARROW  <- '<-' Spacing
SLASH      <- '/' Spacing
AND        <- '&' Spacing
NOT        <- '!' Spacing
QUESTION   <- '?' Spacing
STAR       <- '*' Spacing
PLUS       <- '+' Spacing
OPEN       <- '(' Spacing
CLOSE      <- ')' Spacing
DOT        <- '.' Spacing

Spacing    <- (Space / Comment)*
Comment    <- '#' (!EndOfLine .)* EndOfLine
Space      <- ' ' / '\\t' / EndOfLine
EndOfLine  <- '\\r\\n' / '\\n' / '\\r'
EndOfFile  <- !.
`

		let icons = {
			Grammar: '🖹',
			Reference: '@',
			Literal: '"',
			Range: '𝄩',
			Any: '.',
			Optional: '?',
			ZeroOrMore: '*',
			OneOrMore: '+',
			And: '&',
			Not: '!',
			Sequence: 'ⵈ',
			Choice: '/',
			Action: 'f'
		}

	</script>
</head>

<body>
	<div class="header">
		<center>
			<button onclick="stepBackOut()">↖</button>
			<button onclick="stepBackIn()">↙</button>
			<button onclick="stepBackOver()">↶</button>
			<button onclick="playBack()">◀</button>
			<button onclick="pause()">||</button>
			<button onclick="play()">▶</button>
			<button onclick="stepOver()">↷</button>
			<button onclick="stepIn()">↘</button>
			<button onclick="stepOut()">↗</button>
			&nbsp;
			<input type="checkbox" class="baby" oninput="toggleBaby()">baby steps
		</center>
	</div>
	<div class="grammar">
	</div>
	<div class="stack">
	</div>
	<div class="source" style="white-space: break-spaces;">
	</div>
	<div class="footer">
		status
	</div>

	<script>
		let getId = document.getElementById.bind(document)
		let getCls = c => document.getElementsByClassName(c)[0]

		function unpackProgram(packed) {
			let program = []
			let stack = []
			let activeRules = {}

			function injectRule(cmd) {
				// inject extra step for marking the rule
				rule = { ...cmd }
				rule.op = "@" + cmd.op
				rule.name = activeRules[rule.op].name
				rule.isRuleLabel = true
				program.push(rule)
			}

			for (let packedCmd of packed) {
				let cmd = {}
				if (Array.isArray(packedCmd)) { // enter rule
					cmd.type = "enter"
					cmd.op = "op" + packedCmd[0]
					cmd.pos = packedCmd[1]
					stack.push(cmd)
					if ("@" + cmd.op in activeRules) {
						injectRule(cmd)
					}
					program.push(cmd)
				}

				else if (typeof (packedCmd) == "number") { // accept/reject rule
					cmd.type = packedCmd == F ? "reject" : "accept"
					cmd.match = packedCmd
					cmd.entered = stack.pop()
					cmd.op = cmd.entered.op
					program.push(cmd)
					if ("@" + cmd.op in activeRules) {
						injectRule(cmd)
					}
				}
				else if (packedCmd.type == "Rule") { // create rule
					cmd = { ...packedCmd }
					if (cmd.id in activeRules) {
						cmd.replaces = activeRules[cmd.id]
					}
					console.log(cmd)
					activeRules[cmd.id] = cmd
					program.push(cmd)
				}
				else {
					cmd = { ...packedCmd }
					program.push(cmd)
				}
			}

			for (let i = 0; i < program.length; i++) {
				if (program[i].isRuleLabel) {
					program[i].bigStep = true
					if (program[i].type == "enter") {
						if (i > 0) {
							program[i - 1].bigStep = true
						}
					}
					else {
						if (i < program.length - 1) {
							program[i + 1].bigStep = true
						}
					}
				}
				if (program[i].type == "Rule"
					&& i < program.length - 1
					&& program[i + 1].type != "Rule"
				) {
					program[i].bigStep = true
				}
			}

			return program
		}

		let program = unpackProgram(packedProgram)
		let stack = []
		let popPending = false
		let pc = -1

		/*
		let annotatedSource=[]
		for (c of source){
			annotatedSource.push(["<",c,">"])
		}
		//console.log(annotatedSource.flat().join(""))
		*/

		getCls("source").innerHTML = source.replaceAll("\n", "<br>")

		function markSource(from, len, style) {
			if (from === -1 || from === undefined) {
				getCls("source").innerHTML = source.replaceAll("\n", "<br>")
				return
			}
			let zeroLen = len < 1 ? "0" : ""
			if (len < 1) { len = 1 }
			getCls("source").innerHTML =
				(source.substr(0, from - 1)
					+ '<span class="' + style + zeroLen + '">'
					+ source.substr(from - 1, len)
					+ '</span>'
					+ source.substr(from + len - 1)
				).replaceAll("\n", "<br>")
		}

		function scrollTo(id) {
			let elem = getId(id)
			if (elem) {
				if (document.body.scrollIntoViewIfNeeded) {
					elem.scrollIntoViewIfNeeded()
				}
				else if (document.body.scrollIntoView) {
					elem.scrollIntoView({
						behavior: 'smooth',
						block: 'nearest',
						inline: 'nearest'
					})
				}
			}
		}

		function opType(id) {
			return getId(id).dataset.type
		}

		let babySteps
		function toggleBaby() {
			babySteps = getCls("baby").checked
		}
		toggleBaby()

		function renderGui() {
			for (let cls of ["enter", "accept", "reject"]) {
				for (let elem of document.getElementsByClassName(cls)) {
					elem.className = ""
				}
			}

			if (pc < 0) {
				markSource(-1)
				return
			}

			let cmd = program[pc]

			getCls("stack").innerHTML = ""
			let br = ""
			for (let cmd of stack) {
				getId(cmd.op).className = "inStack"
				if (opType(cmd.op) == "Rule") {
					getCls("stack").innerHTML += br + cmd.name + " "
					br = "<br>"
				}
				else {
					getCls("stack").innerHTML += icons[opType(cmd.op)]
				}
			}

			if (cmd.type == "enter"
				|| cmd.type == "accept"
				|| cmd.type == "reject") {

				getId(cmd.op).className = cmd.type
				if (cmd.type == "enter") {
					markSource(cmd.pos, 0, cmd.type)
				}
				else {
					markSource(cmd.entered.pos, cmd.match, cmd.type)
				}
				scrollTo(cmd.op)
			}

		}

		function step(direction = 1, render = true) {
			while (true) {
				if (popPending) {
					stack.pop()
					popPending = false
				}

				if (direction == 1) {
					if (pc >= program.length - 1) {
						return false
					}
					pc++
				}
				else {
					if (pc < 0) {
						return false
					}
				}

				let cmd = program[pc]

				if (cmd.type == "Grammar") {
					getCls("grammar").innerHTML += cmd.html
				}
				else if (cmd.type == "Rule") {
					getId(cmd.parent).innerHTML += cmd.html
				}
				else { // operator action
					if (direction == 1 && cmd.type == "enter"
						|| direction == -1 && cmd.type != "enter") {
						stack.push(cmd)
					}
					else {
						popPending = true
					}
				}
				if (direction == -1) {
					pc--
				}

				if (babySteps || cmd.bigStep) {
					break
				}
			}

			if (render) {
				renderGui()
			}
			return true
		}

		let metronome;

		function play() {
			clearInterval(metronome)
			metronome = setInterval(
				() => {
					let cont = step()
					if (!cont) {
						clearInterval(metronome)
					}
				},
				20
			)
		}

		function playBack() {
			clearInterval(metronome)
			metronome = setInterval(
				() => {
					let cont = step(-1)
					if (!cont) {
						clearInterval(metronome)
					}
				},
				20
			)
		}

		function pause() {
			clearInterval(metronome)
		}

		function stepIn() { step() }

		function stepBackIn() { step(-1) }

		function skippingStep(direction = 1, out = false) {
			let startStackSize = stack.length
			while (true) {
				let cont = step(direction, false)
				if (
					!cont
					|| !out && (stack.length <= startStackSize)
					|| out && (stack.length < startStackSize)
				) {
					break
				}
			}
			renderGui()
		}

		function stepOver() { skippingStep() }

		function stepBackOver() { skippingStep(-1) }

		function stepOut() { skippingStep(1, true) }

		function stepBackOut() { skippingStep(-1, true) }

		babySteps = true

		renderGui()
		toggleBaby()

	</script>
</body>

</html>