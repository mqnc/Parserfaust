<html>

<head>
	<meta charset="utf-8" />
	<style>
		:root {
			--editor-fg: black;
			--editor-bg: #cad8db;
			--editor-border: #333333;
			--update-fg: black;
			--update-bg: gold;
			--enter-fg: white;
			--enter-bg: #5599ff;
			--accept-fg: black;
			--accept-bg: #45e600;
			--reject-fg: black;
			--reject-bg: #ff570f;
			--not-in-stack-fg: #444444;
			--in-stack-fg: black;
			--in-stack-bg: rgba(200, 100, 255, 0.2);
		}

		body {
			font-family: monospace;
			margin: 0px;
		}

		div {
			color: var(--editor-fg);
			background-color: var(--editor-bg);
			border: solid 1px var(--editor-border);
			position: absolute;
		}

		button {
			line-height: 1em;
		}

		.header {
			left: 5px;
			top: 5px;
			width: calc(100% - 10px);
			height: 2em;
		}

		.grammar {
			left: 5px;
			top: calc(10px + 2em);
			width: calc(0.45*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.stack {
			left: calc(10px + 0.45*(100% - 20px));
			top: calc(10px + 2em);
			width: calc(0.1*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.source {
			left: calc(15px + 0.55*(100% - 20px));
			top: calc(10px + 2em);
			width: calc(0.45*(100% - 20px));
			height: calc(100% - 20px - 4em);
			overflow-y: scroll;
		}

		.footer {
			left: 5px;
			top: calc(100% - 5px - 2em);
			width: calc(100% - 10px);
			height: 2em;
		}

		p {
			color: var(--not-in-stack-fg);
			margin-top: 0.2em;
			margin-bottom: 0.6em;
			padding-left: 3em;
			text-indent: -3em;
		}

		td {
			vertical-align: top;
		}

		.inStack {
			color: var(--in-stack-fg);
			background-color: var(--in-stack-bg);
		}

		.entering {
			color: var(--enter-fg);
			background-color: var(--enter-bg);
		}

		.entering0 {
			background: linear-gradient(90deg, var(--enter-bg) 0%, var(--editor-bg) 70%);
		}

		.accept {
			color: var(--accept-fg);
			background-color: var(--accept-bg);
		}

		.match0 {
			background: linear-gradient(90deg, var(--accept-bg) 0%, var(--editor-bg) 70%);
		}

		.reject {
			color: var(--reject-fg);
			background-color: var(--reject-bg);
		}

		.reject0 {
			background: linear-gradient(90deg, var(--reject-bg) 0%, var(--editor-bg) 70%);
		}

		.update {
			color: var(--update-fg);
			background-color: var(--update-bg);
		}
	</style>
	<script src="test.js"></script>
	<script>

		let source = `# Hierarchical syntax
Grammar    <- Spacing Definition+ EndOfFile
Definition <- Identifier LEFTARROW Expression

Expression <- Sequence (SLASH Sequence)*
Sequence   <- Prefix*
Prefix     <- (AND / NOT)? Suffix
Suffix     <- Primary (QUESTION / STAR / PLUS)?
Primary    <- Identifier !LEFTARROW
            / OPEN Expression CLOSE
            / Literal / Class / DOT

# Lexical syntax
Identifier <- IdentStart IdentCont* Spacing
IdentStart <- [a-zA-Z_]
IdentCont  <- IdentStart / [0-9]

Literal    <- ['] (!['] Char)* ['] Spacing
            / ["] (!["] Char)* ["] Spacing
Class      <- '[' (!']' Range)* ']' Spacing
Range      <- Char '-' Char / Char
Char       <- '\\\\' [nrt'"\\[\\]\\\\]
            / '\\\\' [0-2][0-7][0-7]
            / '\\\\' [0-7][0-7]?
            / !'\\\\' .

LEFTARROW  <- '<-' Spacing
SLASH      <- '/' Spacing
AND        <- '&' Spacing
NOT        <- '!' Spacing
QUESTION   <- '?' Spacing
STAR       <- '*' Spacing
PLUS       <- '+' Spacing
OPEN       <- '(' Spacing
CLOSE      <- ')' Spacing
DOT        <- '.' Spacing

Spacing    <- (Space / Comment)*
Comment    <- '#' (!EndOfLine .)* EndOfLine
Space      <- ' ' / '\\t' / EndOfLine
EndOfLine  <- '\\r\\n' / '\\n' / '\\r'
EndOfFile  <- !.
`

		let icons = {
			Grammar: '🖹',
			Reference: '@',
			Literal: '"',
			Range: '𝄩',
			Any: '.',
			Optional: '?',
			ZeroOrMore: '*',
			OneOrMore: '+',
			And: '&',
			Not: '!',
			Sequence: '⁀',
			Choice: '/',
			Action: 'f'
		}

	</script>
</head>

<body>
	<div class="header">
		<center>
			<!--<button onclick="stepBackOut()">↖</button>
			<button onclick="stepBackIn()">↙</button>
			<button onclick="stepBackOver()">↶</button>
			<button onclick="playBack()">◀</button>-->
			<button onclick="pause()">||</button>
			<button onclick="play()">▶</button>
			<button onclick="stepOver()">↷</button>
			<button onclick="stepIn()">↘</button>
			<button onclick="stepOut()">↗</button>
			&nbsp;
			<input type="checkbox" class="baby" oninput="toggleBaby()">baby steps
		</center>
	</div>
	<div class="grammar">
	</div>
	<div class="stack">
	</div>
	<div class="source">
	</div>
	<div class="footer">
		status
	</div>

	<script>
		let getId = document.getElementById.bind(document)
		let getCls = c => document.getElementsByClassName(c)[0]

		let ruleStack = []
		let babyStack = []
		let pc = -1

		getCls("source").innerHTML = source.replaceAll("\n", "<br>")

		function markSource(from, len, style) {
			if (from === -1 || from === undefined) {
				getCls("source").innerHTML = source.replaceAll("\n", "<br>")
				return
			}
			let zeroLen = len < 1 ? "0" : ""
			if (len < 1) { len = 1 }
			getCls("source").innerHTML =
				(source.substr(0, from - 1)
					+ '<span class="' + style + zeroLen + '">'
					+ source.substr(from - 1, len)
					+ '</span>'
					+ source.substr(from + len - 1)
				).replaceAll("\n", "<br>")
		}

		function opType(id) {
			return getId(id).dataset.type
		}

		let babySteps
		function toggleBaby() {
			babySteps = getCls("baby").checked
		}
		toggleBaby()

		function renderGui() {
			for (let cls of ["entering", "accept", "reject"]) {
				for (let elem of document.getElementsByClassName(cls)) {
					elem.className = ""
				}
			}

			if (pc < 0) {
				markSource(-1)
				return
			}

			let cmd = program[pc]

			getCls("stack").innerHTML = ""
			let br = ""
			for (let op of babyStack) {
				getId(op).className = "inStack"
				if (opType(op)=="Rule") {
					getCls("stack").innerHTML += br + op + " "
					br = "<br>"
				}
				else {
					getCls("stack").innerHTML += icons[opType(op)]
				}
			}

			let scrollTo

			if (!Array.isArray(cmd)) { // grammar or rule creation

			}
			else { // operator action
				let op = cmd[0]
				let entering = cmd.length === 2
				let pos = cmd[1]
				let match = entering ? 0 : cmd[2]

				if (entering) {
					getId(op).className = "entering"
					markSource(pos, match, "entering")
				}
				else if (match > -1) {
					getId(op).className = "accept"
					markSource(pos, match, "accept")
				}
				else {
					getId(op).className = "reject"
					markSource(pos, match, "reject")
				}
				scrollTo = op
			}

			if (document.body.scrollIntoViewIfNeeded) {
				getId(scrollTo).scrollIntoViewIfNeeded()
			}
			else if (document.body.scrollIntoView) {
				getId(scrollTo).scrollIntoView({
					behavior: 'smooth',
					block: 'nearest',
					inline: 'nearest'
				})
			}

		}

		function step(direction = 1, render = true) {
			while (true) {
				if (direction == 1) {
					if (pc >= program.length - 1) {
						return false
					}
					pc++
				}
				else {
					if (pc < 0) {
						return false
					}
				}

				let cmd = program[pc]
				let op = cmd[0]
				let entering = cmd.length === 2
				let pos = cmd[1]
				let match = entering ? 0 : cmd[2]

				if (!Array.isArray(cmd)) { // grammar/rule creation
					if ('grammar' in cmd) {
						getCls("grammar").innerHTML +=
							"<table id='" + cmd.grammar + "' data-type='Grammar'></table>"
					}
					else if ('rule' in cmd) {
						getId(cmd.parent).innerHTML +=
							"<tr><td><span id='" + cmd.rule
							+ "' data-type='Rule'>"
							+ cmd.rule + "</span></td>"
							+ "<td> &lt;- </td>"
							+ "<td>" + cmd.def + "</td></tr>"
					}
				}
				else { // operator action
					if (direction == 1 && entering || direction == -1 && !entering) {
						if (opType(op) === "Rule") { ruleStack.push(op) }
						babyStack.push(op)
					}
					else {
						if (opType(op) === "Rule") { ruleStack.pop() }
						babyStack.pop()
					}
				}
				if (direction == -1) {
					pc--
				}

				if (babySteps || opType(op) === "Reference" || opType(op) === "Rule") {
					break
				}
			}

			if (render) {
				renderGui()
			}
			return true
		}

		let metronome;

		function play() {
			clearInterval(metronome)
			metronome = setInterval(
				() => {
					let cont = step()
					if (!cont) {
						clearInterval(metronome)
					}
				},
				20
			)
		}

		function playBack() {
			clearInterval(metronome)
			metronome = setInterval(
				() => {
					let cont = step(-1)
					if (!cont) {
						clearInterval(metronome)
					}
				},
				20
			)
		}

		function pause() {
			clearInterval(metronome)
		}

		function stepIn() { step() }

		function stepBackIn() { step(-1) }

		function skippingStep(direction = 1, out = false) {
			let stack = babySteps ? babyStack : ruleStack
			let startStackSize = stack.length
			while (true) {
				let cont = step(direction, false)
				if (!cont
					|| !out && stack.length <= startStackSize
					|| out && stack.length < startStackSize
				) {
					break
				}
			}
			renderGui()
		}

		function stepOver() { skippingStep() }

		function stepBackOver() { skippingStep(-1) }

		function stepOut() { skippingStep(1, true) }

		function stepBackOut() { skippingStep(-1, true) }

		babySteps = true
		while (!Array.isArray(program[pc])) {
			step(1, false)
		}
		renderGui()
		toggleBaby()

	</script>
</body>

</html>